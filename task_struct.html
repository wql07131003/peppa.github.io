<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>NUMA (Non-Uniform Memory Access): An Overview</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dirtysalt" />
<link rel="shortcut icon" href="https://dirtysalt.github.io/css/favicon.ico" />
<link rel="stylesheet" type="text/css" href="./css/site.css" />
</head>
<body>
<div id="content">
<h1 class="title">task_struct（进程描述符）</h1>
<p>
<a href="http://blog.csdn.net/qq_33417547/article/details/72799875">http://blog.csdn.net/qq_33417547/article/details/72799875</a>
</p>

<p>
进程是一个正在执行的程序。 
进程是程序的一个运行实例。 
进程能分配处理器并由处理器执行的实体。 
如果从内核的角度看的话：进程是分配系统资源的单位。当一个程序被加载到内存之后并为他分配一个PCB(进程控制块),这时候就称为进程了。在linux中PCB就是一个名字叫做task_struct的结构体,我们叫他”进程描述符”。它里面有进程执行的所有信息，所以CPU对task_struct进行管理就相当于在对进程进行管理。 
PCB叫做进程控制块，它用来维护进程相关的信息，每个进程都有一个PCB。在linux中这个PCB是一个叫做task_struct的结构体。
</p>

<p>
task_struct ：
在linux中，每一个进程都有一个进程描述符，这个”进程描述符”是一个结构体名字叫做task_struct，在task_struct里面保存了许多关于进程控制的信息。 
task_struct是Linux内核的一种数据结构，它会被装载到RAM里并包含进程的信息。每个进程都把它的信息放在task_struct这个数据结构里面，而task_struct包含以下内容： 
标示符：描述本进程的唯一标示符，用来区别其他进程。 
状态：任务状态，退出代码，退出信号等。 
优先级：相对于其他进程的优先级。 
程序计数器：程序中即将被执行的下一条指令的地址。 
内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。 
上下文数据：进程执行时处理器的寄存器中的数据。 
I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和正在被进程使用的文件列表。 
记账信息：可能包括处理器时间总和，使用的时钟总数，时间限制，记账号等。
文件系统数据成员：
(1) struct fs_struct *fs; 
(2) struct files_struct *files; 
(3) int link_count;
</p>

<pre class="brush:cpp;toolbar:false"><br/></pre>
<p>
    struct task_struct {
</p>
<p>
    volatile long state; &nbsp;//说明了该进程是否可以执行,还是可中断等信息
</p>
<p>
    unsigned long flags; &nbsp;//Flage 是进程号,在调用fork()时给出
</p>
<p>
    int sigpending; &nbsp; &nbsp;//进程上是否有待处理的信号
</p>
<p>
    mm_segment_t addr_limit; //进程地址空间,区分内核进程与普通进程在内存存放的位置不同
</p>
<p>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //0-0xBFFFFFFF for user-thead
</p>
<p>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //0-0xFFFFFFFF for kernel-thread
</p>
<p>
    //调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度
</p>
<p>
    volatile long need_resched;
</p>
<p>
    int lock_depth; &nbsp;//锁深度
</p>
<p>
    long nice; &nbsp; &nbsp; &nbsp; //进程的基本时间片
</p>
<p>
    //进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER
</p>
<p>
    unsigned long policy;
</p>
<p>
    struct mm_struct *mm; //进程内存管理信息
</p>
<p>
    int processor;
</p>
<p>
    //若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新
</p>
<p>
    unsigned long cpus_runnable, cpus_allowed;
</p>
<p>
    struct list_head run_list; //指向运行队列的指针
</p>
<p>
    unsigned long sleep_time; &nbsp;//进程的睡眠时间
</p>
<p>
    //用于将系统中所有的进程连成一个双向循环链表, 其根是init_task
</p>
<p>
    struct task_struct *next_task, *prev_task;
</p>
<p>
    struct mm_struct *active_mm;
</p>
<p>
    struct list_head local_pages; &nbsp; &nbsp; &nbsp; //指向本地页面 &nbsp; &nbsp; &nbsp;
</p>
<p>
    unsigned int allocation_order, nr_local_pages;
</p>
<p>
    struct linux_binfmt *binfmt; &nbsp;//进程所运行的可执行文件的格式
</p>
<p>
    int exit_code, exit_signal;
</p>
<p>
    int pdeath_signal; &nbsp; &nbsp; //父进程终止时向子进程发送的信号
</p>
<p>
    unsigned long personality;
</p>
<p>
    //Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序
</p>
<p>
    int did_exec:1;&nbsp;
</p>
<p>
    pid_t pid; &nbsp; &nbsp;//进程标识符,用来代表一个进程
</p>
<p>
    pid_t pgrp; &nbsp; //进程组标识,表示进程所属的进程组
</p>
<p>
    pid_t tty_old_pgrp; &nbsp;//进程控制终端所在的组标识
</p>
<p>
    pid_t session; &nbsp;//进程的会话标识
</p>
<p>
    pid_t tgid;
</p>
<p>
    int leader; &nbsp; &nbsp; //表示进程是否为会话主管
</p>
<p>
    struct task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr;
</p>
<p>
    struct list_head thread_group; &nbsp; //线程链表
</p>
<p>
    struct task_struct *pidhash_next; //用于将进程链入HASH表
</p>
<p>
    struct task_struct **pidhash_pprev;
</p>
<p>
    wait_queue_head_t wait_chldexit; &nbsp;//供wait4()使用
</p>
<p>
    struct completion *vfork_done; &nbsp;//供vfork() 使用
</p>
<p>
    unsigned long rt_priority; //实时优先级，用它计算实时进程调度时的weight值
</p>
<p>
    <br/>
</p>
<p>
    //it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value
</p>
<p>
    //设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据
</p>
<p>
    //it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。
</p>
<p>
    //当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送
</p>
<p>
    //信号SIGPROF，并根据it_prof_incr重置时间.
</p>
<p>
    //it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种
</p>
<p>
    //状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据
</p>
<p>
    //it_virt_incr重置初值。
</p>
<p>
    unsigned long it_real_value, it_prof_value, it_virt_value;
</p>
<p>
    unsigned long it_real_incr, it_prof_incr, it_virt_value;
</p>
<p>
    struct timer_list real_timer; &nbsp; //指向实时定时器的指针
</p>
<p>
    struct tms times; &nbsp; &nbsp; &nbsp;//记录进程消耗的时间
</p>
<p>
    unsigned long start_time; &nbsp;//进程创建的时间
</p>
<p>
    //记录进程在每个CPU上所消耗的用户态时间和核心态时间
</p>
<p>
    long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];&nbsp;
</p>
<p>
    //内存缺页和交换信息:
</p>
<p>
    //min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换
</p>
<p>
    //设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。
</p>
<p>
    //cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。
</p>
<p>
    //在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中
</p>
<p>
    unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
</p>
<p>
    int swappable:1; //表示进程的虚拟地址空间是否允许换出
</p>
<p>
    //进程认证信息
</p>
<p>
    //uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid
</p>
<p>
    //euid，egid为有效uid,gid
</p>
<p>
    //fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件
</p>
<p>
    //系统的访问权限时使用他们。
</p>
<p>
    //suid，sgid为备份uid,gid
</p>
<p>
    uid_t uid,euid,suid,fsuid;
</p>
<p>
    gid_t gid,egid,sgid,fsgid;
</p>
<p>
    int ngroups; //记录进程在多少个用户组中
</p>
<p>
    gid_t groups[NGROUPS]; //记录进程所在的组
</p>
<p>
    //进程的权能，分别是有效位集合，继承位集合，允许位集合
</p>
<p>
    kernel_cap_t cap_effective, cap_inheritable, cap_permitted;
</p>
<p>
    int keep_capabilities:1;
</p>
<p>
    struct user_struct *user;
</p>
<p>
    struct rlimit rlim[RLIM_NLIMITS]; &nbsp;//与进程相关的资源限制信息
</p>
<p>
    unsigned short used_math; &nbsp; //是否使用FPU
</p>
<p>
    char comm[16]; &nbsp; //进程正在运行的可执行文件名
</p>
<p>
    &nbsp;//文件系统信息
</p>
<p>
    int link_count, total_link_count;
</p>
<p>
    //NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空
</p>
<p>
    struct tty_struct *tty;
</p>
<p>
    unsigned int locks;
</p>
<p>
    //进程间通信信息
</p>
<p>
    struct sem_undo *semundo; &nbsp;//进程在信号灯上的所有undo操作
</p>
<p>
    struct sem_queue *semsleeping; //当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作
</p>
<p>
    //进程的CPU状态，切换时，要保存到停止进程的task_struct中
</p>
<p>
    struct thread_struct thread;
</p>
<p>
    &nbsp; //文件系统信息
</p>
<p>
    struct fs_struct *fs;
</p>
<p>
    &nbsp; //打开文件信息
</p>
<p>
    struct files_struct *files;
</p>
<p>
    &nbsp; //信号处理函数
</p>
<p>
    spinlock_t sigmask_lock;
</p>
<p>
    struct signal_struct *sig; //信号处理函数
</p>
<p>
    sigset_t blocked; &nbsp;//进程当前要阻塞的信号，每个信号对应一位
</p>
<p>
    struct sigpending pending; &nbsp;//进程上是否有待处理的信号
</p>
<p>
    unsigned long sas_ss_sp;
</p>
<p>
    size_t sas_ss_size;
</p>
<p>
    int (*notifier)(void *priv);
</p>
<p>
    void *notifier_data;
</p>
<p>
    sigset_t *notifier_mask;
</p>
<p>
    u32 parent_exec_id;
</p>
<p>
    u32 self_exec_id;
</p>
<p>
    <br/>
</p>
<p>
    spinlock_t alloc_lock;
</p>
<p>
    void *journal_info;
</p>
<p>
    };
</p>
<p>
    <br/>
</p>

</div>
<!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'numa-an-overview.html';var disqus_title = 'numa-an-overview.html';var disqus_url = 'http://dirtysalt.github.io/numa-an-overview.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
